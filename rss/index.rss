<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Hello World! I'm Vincent</title><description>Thoughts, stories and ideas.</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Thu, 24 Mar 2016 17:59:09 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>不一樣的 Node.js 筆記 (一)</title><description>&lt;p&gt;原著：不一樣的 Node.js－用 JavaScript 打造高效能的前後台網頁程式 林政毅、蔡政崇、錢逢祥 (2014/05/12)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者群 期許本書可以替讀者勾勒出 Node.js 的技術藍圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="nodejs"&gt;Node.js 簡介&lt;/h2&gt;

&lt;p&gt;Node.js 為一個 opensource 的框架, 採用了 Chrome's V8 JavaScript Engine。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它讓 Javascript 可以獨立運行於瀏覽器之外。&lt;/li&gt;
&lt;li&gt;制定了一系列機制於 API 來協助達到原生 JavaScript 所不支援的功能 (ex. Module、FileSystem、Socket、Process ...etc)&lt;/li&gt;
&lt;li&gt;支援第三方模組的功能擴充&lt;/li&gt;
&lt;li&gt;繼承 JavaScript 中 Event-driven&lt;/li&gt;&lt;/ul&gt;</description><link>http://localhost:2368/bu-yi-yang-de-node-js-bi-ji/</link><guid isPermaLink="false">8ccbede2-6c6b-4362-9e42-3800e73a3c83</guid><dc:creator>Captain Vincent</dc:creator><pubDate>Tue, 22 Mar 2016 12:34:46 GMT</pubDate><content:encoded>&lt;p&gt;原著：不一樣的 Node.js－用 JavaScript 打造高效能的前後台網頁程式 林政毅、蔡政崇、錢逢祥 (2014/05/12)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者群 期許本書可以替讀者勾勒出 Node.js 的技術藍圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="nodejs"&gt;Node.js 簡介&lt;/h2&gt;

&lt;p&gt;Node.js 為一個 opensource 的框架, 採用了 Chrome's V8 JavaScript Engine。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它讓 Javascript 可以獨立運行於瀏覽器之外。&lt;/li&gt;
&lt;li&gt;制定了一系列機制於 API 來協助達到原生 JavaScript 所不支援的功能 (ex. Module、FileSystem、Socket、Process ...etc)&lt;/li&gt;
&lt;li&gt;支援第三方模組的功能擴充&lt;/li&gt;
&lt;li&gt;繼承 JavaScript 中 Event-driven 的非同步特性


&lt;blockquote&gt;
  書中作者認定 Event-driven 的非同步概念是與多工/緒是不同的, 但筆者認為 Event-driven 其實也只是一種使用多工/緒鑄成的樣板, 透過用多工/緒的方式來將執行與等待的動作拆分開來。&lt;/blockquote&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h3 id=""&gt;優勢&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;統一前後開發的經驗&lt;/li&gt;
&lt;li&gt;開發效率高 (見仁見智)&lt;/li&gt;
&lt;li&gt;極佳的效能 (雖然 JIT 的技術引進後, 仍有無法跟原生的程式相抗衡的宿命)&lt;/li&gt;
&lt;li&gt;數以萬計的第三方模組支援&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="javascript"&gt;JavaScript 簡介&lt;/h3&gt;

&lt;p&gt;又稱做 ECMAScript (&lt;a href="https://zh.wikipedia.org/wiki/JavaScript"&gt;Wiki 傳送門&lt;/a&gt;),
在瀏覽器百家爭鳴的年代, 各家對 JavaScipt 實作的支援與標準不同, 最後由 ECMA 的協調下統一制定了 ECMA-262的標準。&lt;/p&gt;

&lt;p&gt;目前常見的 JavaScript Engine有&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;V8 - Google Chrome 所使用, 首先引入 JIT 技術&lt;/li&gt;
&lt;li&gt;SpiderMonkey - Mozilla FireFox 所使用, 由 Javascript 語言發明人 Brendan Eich 開發; 而 Mozilla 基金會的前身是由當時被 IE 所擊敗的 Netscape 為了託管其 opensource 的專案所成立&lt;/li&gt;
&lt;li&gt;Chakra - 微軟 IE 9.0 之後開始搭載&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2 id="javascript"&gt;JavaScript 語法&lt;/h2&gt;

&lt;p&gt;因為 Node.js 是 base on JavaScript 而衍伸的, 所以在語法上我們還是要回來介紹 JavaScript 做為基石。 &lt;/p&gt;

&lt;h3 id=""&gt;變數宣告&lt;/h3&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var MyName = 'Vincent'; //顯式宣告  
YourName = 'Guest'; //隱式宣告  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=""&gt;變數型別&lt;/h3&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var text = undefined; //未宣告的變數或宣告後未初始化  
var text = 'string'; //字串  
var text = 520; //64 bit 浮點數  
var text = true; //布林變數 true or false  
var text = function() {}; //函數  
var text = null; //釋放物件時指向 null  
var text = { key1 : 1}; //物件  
var text = [5,2,0]; //陣列  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id="string"&gt;字串 (String)&lt;/h5&gt;

&lt;p&gt;只要用雙/單引號括起來的都是字串類型, 底下是特殊字元的介紹。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; 換行鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\r&lt;/code&gt; 回車鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\t&lt;/code&gt; Tab 鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\b&lt;/code&gt; 刪除鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\f&lt;/code&gt; 換頁鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\'&lt;/code&gt; 單引號&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\"&lt;/code&gt; 雙引號&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\\&lt;/code&gt; 反斜線 (單一個反斜線稱跳脫字元, 需連續兩個才能秀出字元)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\x00 - \xFF&lt;/code&gt; (16 bit 的字元)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\u0000 - \uFFFF&lt;/code&gt; (Unicode 字元)&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="number"&gt;數值 (Number)&lt;/h5&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var num1 = .0001 //可省略小數點前的 0  
var num2 = 1E-4 //科學記號  
var num3 = 0x123 //16 進位表示, 不接受小數點  
var num4 = 0123 //0 開頭表示 8 進位數字, 不接受小數點  
Infinity //無窮大  
NaN //代表非數字, 變數未初始化就進行數字運算時會回傳該值  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id="function"&gt;函式 (Function)&lt;/h5&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;function FunctionName(parameter)  
{
    ...
    return result; // 可以有回傳值也可無
} //一般的命名方式來建立函式

var fnVar = function(parameter)  
{
    ...
} //使用變數承接匿名函式, 後續可透過 fnVar 來呼叫

(function(parameter){
    ...
}('test')) //在匿名函式後直接使用'()'來馬上呼叫
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函式可以使用關鍵字 function 做宣告, 沒有提供 function name 時則是匿名 (Anonymous) 函式 (第一版書中有誤)。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var functionOne = function(){console.log("hello world!")};  
var functionTwo = new Function('console.log("hello world!")');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立函式還可另外分為兩種類型, 一個會建立成 function 另一個則是 object。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp"&gt;JavaScript 內建全域函式&lt;/a&gt;&lt;/p&gt;

&lt;h5 id="object"&gt;物件 (Object)&lt;/h5&gt;

&lt;p&gt;物件擁有自己的屬性 (properties) 以及方法 (methods)。&lt;/p&gt;

&lt;h5 id="array"&gt;陣列 (Array)&lt;/h5&gt;

&lt;p&gt;亦是一種物件類型 (所以有提供以下方法 push、pop、shift、unshift、splice ...etc), 陣列元素也可以是不同的類型。&lt;/p&gt;

&lt;h3 id="json"&gt;JSON&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;J&lt;/strong&gt;ava&lt;strong&gt;S&lt;/strong&gt;cript &lt;strong&gt;O&lt;/strong&gt;bject &lt;strong&gt;N&lt;/strong&gt;otation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;輕量級的資料交換語言, 為獨立程式語言外的格式定義語法 且 目前已被多種程式語言所支援。&lt;/li&gt;
&lt;li&gt;相對於傳統的關係型資料庫，一些關係型資料庫 (NoSQL) 選擇 JSON 作為其資料儲存格式 (MongoDB、CouchDB、RavenDB ...etc)。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var myObj = new Object();  
myObj.name = 'Vincent';  
myObj.gender = 'Male';

var myArray = new Array('one', 'two', 'three');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;標準建立 Object 與 Array的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var myObj  
{
    'name' : 'Vincent';
    'gender' : 'Male';
};

var myArray = ['one', 'two', 'three'];  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 JSON 語法 ([]、{} 與 、) 描述建立的 Object 與 Array (鍵值與元素皆可支援 64 bit 浮點數)&lt;/p&gt;

&lt;p&gt;JSON 格式的文字檔可透過 JavaScript 內建的函式處理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSON.stringify() 轉換陣列或物件成 JSON 格式的資料&lt;/li&gt;
&lt;li&gt;JSON.parser() 將 JSON 格式的資料轉成物件或陣列&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=""&gt;運算符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, 以上為常見的算數運算符&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;+&lt;/code&gt; 同時具有字串串接的功能, 所以在表達式中需注意, 運算符會從算式由左至右運算&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (and), &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;~&lt;/code&gt; (not), &lt;code&gt;^&lt;/code&gt; (xor), &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; (位元左移), &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (位元右移), &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (位元無符號右移), 以上為位元 (bitwise) 運算符號&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt; (左值等於右值 且 兩邊資料類型也相同時為 true, 反之 false), &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt; (與 === 相反意思), &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, 以上為比較與邏輯運算符&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;===&lt;/code&gt; 在物件的比較上, 還會比對參考的位置是否相同, 兩個物件雖含相同元素內容仍會比對結果 false&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=""&gt;特殊用法&lt;/h3&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var a=1;  
var b=2;

typeof("abc"); //回傳資料類型

var result1 = (a == b)? true:false; //條件式成立與否決定後續的回傳值

var result2 = instanceof "abc" instanceof String;  
//回傳是否為該物件類型, 注意這邊 "abc" 為 string 類型, 但並非 String Object

var result3 = (a++, b++, a+b); //依序執行並會傳最後一個算式的結果

var result4 = delete a; //將變量重設為 undefined, 並回傳成功與否

var result5 = void b++; //放棄運算結果用 undefined 代替回傳  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=""&gt;流程控制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;if... else... if&lt;/li&gt;
&lt;li&gt;switch... case&lt;/li&gt;
&lt;li&gt;for... loop&lt;/li&gt;
&lt;li&gt;for... in&lt;/li&gt;
&lt;li&gt;while... loop&lt;/li&gt;
&lt;li&gt;do... while&lt;/li&gt;
&lt;li&gt;continue、break、(return、throw 省略未介紹)&lt;/li&gt;
&lt;li&gt;with&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;範例&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;var condition = 3;  
var list = [  
    {id:1, name='Vincent'},
    {id:2, name='Miyu'},
    {id:3, name='Guest'}
];
// JSON 格式建立陣列

// if... else if... else... 
if (condition == 1) {  
    ....
}
else if(condition == 2) {  
    ....
}
else {  
    ....
};

// switch... case...
switch (condition) {  
    case 1:
        ...
        break;
    case 2:
        ...
        break;
    default:
        ...
}

// for... loop
for (var index=0 ; index&amp;lt;3 ; index++)  
{
    ...
}

// for... in
for (var i in list){  
    var obj = list[i];
    console.log(obj.id + ':' + obj.name);
}

// while... loop
var i = 0;  
while (i&amp;lt;=3)  
{
    ...
    i++;
}

// do... while
var j = 0;  
do  
{
    ...
    j++;
} while (j&amp;lt;3);

// continue、break
for (var index=0 ; index&amp;lt;10 ; index++)  
{
    if(index == 1){
        continue; //會跳開此次迴圈的執行, 執行下一次迴圈
    }

    if(index == 5)
    {
        break; //會直接離開迴圈
    }
    console.log(index);
}

// with (strict mode 無法使用)
for (var i in list){  
    var obj = list[i];
    with (obj) {
        console.log(id + ':' + name); 
        //with的功用主要是用來省略物件名稱
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="prototype"&gt;原型 (Prototype)&lt;/h3&gt;

&lt;p&gt;Prototype 應用於將 JavaScript 中屬於同建構子 (constructor) 建立的所有物件, 把可以共享的部分獨立出來, 避免重複建立的問題。  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;function Person(age,id){  
    this.age = age;
    this.id = id;
}

Person.prototype.address = 'taipei';

Person.prototype.out = function(){  
    console.log('age:' + this.age + ' id:' + this.id + ' address:' + this.address);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(address 與 out 為所有物件共享) &lt;/p&gt;

&lt;h3 id="gcgarbagecollection"&gt;記憶體回收機制 (GC, Garbage Collection)&lt;/h3&gt;

&lt;p&gt;透過計算指向物件的 reference count 來確認該物件是否仍被使用, 當 reference count 降為 0 時便釋放該記憶體空間。&lt;/p&gt;</content:encoded></item><item><title>道氏理論的 21 招選股技巧 筆記 (Mind Map)</title><description>&lt;p&gt;原著：道氏理論的21招選股技巧 陳東 (2012/04/01)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;History repeats itself. 技術面操盤者心中共同的信念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;關於 Mind Map 內的筆記整理, 是筆者消化後認為有可能後續實驗可以參考的法則, 有可能並未忠實呈現道氏理論原先的面貌 (或本書作者的完整意思), 像道氏理論中對於各技術分析的指標都會強調求出其三重型態或是至少求出中、短期的線圖, 但筆者的重心僅在這些技術指標的特徵描述, 實際應用時應再自行驗證加入主觀意識的部分。&lt;/p&gt;

&lt;h2 id="mindmap"&gt;筆記 (Mind Map)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用方式類似 Google Map 的拖曳操作可以移動畫面, 右鍵可以彈出放大鏡的按鈕, 按壓放大鏡拖曳後可以 Zoom In/Out&lt;/p&gt;
&lt;/blockquote&gt;

&lt;iframe width="853" height="480" src="https://embed.coggle.it/diagram/Vu5LNj_zpOYo1mzy/739e465141646161dad5c001a099ada2bdb261208d58eeee6ca71408a3c87dfe" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><link>http://localhost:2368/dao-shi-li-lun-de-21-zhao-xuan-gu-ji-qiao/</link><guid isPermaLink="false">c3e8ac2f-03b6-4684-88da-f10b74881e2c</guid><dc:creator>Captain Vincent</dc:creator><pubDate>Sat, 19 Mar 2016 12:05:46 GMT</pubDate><content:encoded>&lt;p&gt;原著：道氏理論的21招選股技巧 陳東 (2012/04/01)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;History repeats itself. 技術面操盤者心中共同的信念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;關於 Mind Map 內的筆記整理, 是筆者消化後認為有可能後續實驗可以參考的法則, 有可能並未忠實呈現道氏理論原先的面貌 (或本書作者的完整意思), 像道氏理論中對於各技術分析的指標都會強調求出其三重型態或是至少求出中、短期的線圖, 但筆者的重心僅在這些技術指標的特徵描述, 實際應用時應再自行驗證加入主觀意識的部分。&lt;/p&gt;

&lt;h2 id="mindmap"&gt;筆記 (Mind Map)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用方式類似 Google Map 的拖曳操作可以移動畫面, 右鍵可以彈出放大鏡的按鈕, 按壓放大鏡拖曳後可以 Zoom In/Out&lt;/p&gt;
&lt;/blockquote&gt;

&lt;iframe width="853" height="480" src="https://embed.coggle.it/diagram/Vu5LNj_zpOYo1mzy/739e465141646161dad5c001a099ada2bdb261208d58eeee6ca71408a3c87dfe" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</content:encoded></item><item><title>Kelly Formula / 凱利公式 － 風險控管</title><description>&lt;blockquote&gt;
  &lt;p&gt;投資 vs 投機 vs 賭博, 不管你自認為是使用以上三種策略的那一種人, 今天要介紹的是一門讓你在這條路上可以走得更遠、更久的準則－&lt;strong&gt;Kelly Formula&lt;/strong&gt;, 先來上一堂數學課吧! &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="kellyformula"&gt;Kelly Formula&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1497/25083691774_dba0e65847_o.jpg" alt="Kelly Formula"&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b : 賠率 (獲勝後的報償比上本金的比例, ex. 賭上 1 元, 獲勝可拿回 1+b 元)&lt;/li&gt;
&lt;li&gt;p : 勝率 (獲勝的機率)&lt;/li&gt;
&lt;li&gt;q : 敗率 (1-p)&lt;/li&gt;
&lt;li&gt;f : 為使用現有資金應進行投注的比例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kelly Formula 為求最大期望值時, 應投入的資金比例 (其中 b、p、q 皆為不變常數) &lt;br&gt;
from &lt;a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E5%88%A9%E5%85%AC%E5%BC%8F"&gt;Wiki&lt;/a&gt;  &lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=""&gt;證明&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;X&lt;sub&gt;n&lt;/sub&gt; : 表示 經過 n&lt;/li&gt;&lt;/ul&gt;</description><link>http://localhost:2368/kelly-formula/</link><guid isPermaLink="false">8fbf310e-9b7b-4bac-a24e-c1c22ca661a4</guid><dc:creator>Captain Vincent</dc:creator><pubDate>Fri, 11 Mar 2016 10:57:55 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;投資 vs 投機 vs 賭博, 不管你自認為是使用以上三種策略的那一種人, 今天要介紹的是一門讓你在這條路上可以走得更遠、更久的準則－&lt;strong&gt;Kelly Formula&lt;/strong&gt;, 先來上一堂數學課吧! &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="kellyformula"&gt;Kelly Formula&lt;/h2&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1497/25083691774_dba0e65847_o.jpg" alt="Kelly Formula"&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;b : 賠率 (獲勝後的報償比上本金的比例, ex. 賭上 1 元, 獲勝可拿回 1+b 元)&lt;/li&gt;
&lt;li&gt;p : 勝率 (獲勝的機率)&lt;/li&gt;
&lt;li&gt;q : 敗率 (1-p)&lt;/li&gt;
&lt;li&gt;f : 為使用現有資金應進行投注的比例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kelly Formula 為求最大期望值時, 應投入的資金比例 (其中 b、p、q 皆為不變常數) &lt;br&gt;
from &lt;a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E5%88%A9%E5%85%AC%E5%BC%8F"&gt;Wiki&lt;/a&gt;  &lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=""&gt;證明&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;X&lt;sub&gt;n&lt;/sub&gt; : 表示 經過 n 次賭局後所剩的資金 (n=0, 表示初始資金)&lt;/li&gt;
&lt;li&gt;W&lt;sub&gt;n&lt;/sub&gt; : 表示 經過 n 次賭局, Win 的次數&lt;/li&gt;
&lt;li&gt;L&lt;sub&gt;n&lt;/sub&gt; : 表示 經過 n 次賭局, Loss 的次數&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Two Cases&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;X&lt;sub&gt;n&lt;/sub&gt; = X&lt;sub&gt;n-1&lt;/sub&gt; ( 1 + bf )
&lt;br&gt;Win case, 剩餘金額 = 前次金額 * (1 + 賠率*前次投注的比例)  &lt;/li&gt;
&lt;li&gt;X&lt;sub&gt;n&lt;/sub&gt; = X&lt;sub&gt;n-1&lt;/sub&gt; ( 1 - f )
&lt;br&gt;Loss case, 剩餘金額 = 前次金額 * (1 - 前次損失的比例)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更進一步可以理解&lt;/p&gt;

&lt;p&gt;X&lt;sub&gt;n&lt;/sub&gt; = X&lt;sub&gt;0&lt;/sub&gt; ( 1 - f ) &lt;sup&gt;Ln&lt;/sup&gt; ( 1 + bf ) &lt;sup&gt;Wn&lt;/sup&gt; ... (式1) &lt;br&gt;
剩餘金額 = 初始金額 * (失敗 case)&lt;sup&gt;失敗次數&lt;/sup&gt; * (勝利 case)&lt;sup&gt;勝利次數&lt;/sup&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;參考文獻中更進一步的將 Loss Case 中的賠率 (賠給對方), 另外定義為 a, 所以整理得到的公式會如下&lt;/p&gt;
  
  &lt;p&gt;X&lt;sub&gt;n&lt;/sub&gt; = X&lt;sub&gt;0&lt;/sub&gt; ( 1 - af ) &lt;sup&gt;Ln&lt;/sup&gt; ( 1 + bf ) &lt;sup&gt;Wn&lt;/sup&gt; ... (式2)&lt;/p&gt;
  
  &lt;p&gt;而 (式1) 只是當 a=1 的 special case (表示當輸了時, 會造成該次投注金額全部損失)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Reference &lt;a href="https://www.math.washington.edu/~morrow/336_10/papers/jane.pdf"&gt;Betting with the Kelly Criterion&lt;/a&gt;, Jane Hung (June 2,2010)&lt;/p&gt;

&lt;p&gt;這邊先以 (式2) 來求 f 的最佳值, 首先對 &lt;strong&gt;方程式&lt;/strong&gt; 的左右兩側同時&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除以 X&lt;sub&gt;0&lt;/sub&gt;  &lt;/li&gt;
&lt;li&gt;取 ln (ln = log&lt;sub&gt;e&lt;/sub&gt;) &lt;br&gt;
因為 ln 為嚴格遞增函數, 所以對 &lt;strong&gt;方程式&lt;/strong&gt; 兩側作用後, 不影響求極大值的條件。&lt;br&gt;
(若 x&lt;sub&gt;1&lt;/sub&gt;、x&lt;sub&gt;2&lt;/sub&gt; 為實數 且 x&lt;sub&gt;1&lt;/sub&gt;&gt;x&lt;sub&gt;2&lt;/sub&gt;, 則 f(x&lt;sub&gt;1&lt;/sub&gt;) &gt; f(x&lt;sub&gt;2&lt;/sub&gt;)恆成立, 滿足此條件的 f(x) 稱為 &lt;strong&gt;嚴格遞增函數&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;除以 n (當 n&gt;0 時, 也可視為嚴格遞增)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;透過使用下列對數律&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;log&lt;sub&gt;a&lt;/sub&gt; X*Y = log&lt;sub&gt;a&lt;/sub&gt; X + log&lt;sub&gt;a&lt;/sub&gt; Y&lt;/li&gt;
&lt;li&gt;b * log&lt;sub&gt;a&lt;/sub&gt; X = log&lt;sub&gt;a&lt;/sub&gt; X &lt;sup&gt;b&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;化簡後如下 ... (式3)
&lt;img src="https://farm2.staticflickr.com/1669/25690346716_7d44c0666a.jpg" alt="Step1"&gt;&lt;/p&gt;

&lt;p&gt;新定義一個函式為 G(f) = (式3), 因 L&lt;sub&gt;n&lt;/sub&gt; / n = q、W&lt;sub&gt;n&lt;/sub&gt; / n = p (來自於 p、q 本身的定義為勝率跟敗率), 所以得到&lt;/p&gt;

&lt;p&gt;G(f) = q (ln (1-af)) + p (ln (1+bf))&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目前問題已經轉化為要求 G(f) 的最大值時, f 應該使用多少?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;這邊一階微分在數學上的意義是斜率, 所以當我們今天要找極大值相當於我們要找出斜率 = 0 的點, 所以我們先找出 G'(f) = 0 的 f 值有哪些? &lt;/p&gt;

&lt;p&gt;使用 &lt;a href="https://en.wikipedia.org/wiki/Chain_rule"&gt;Chain Rule&lt;/a&gt; 技巧可以得到下面結果&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1702/25719192595_02cd415376_n.jpg" alt="Step2"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1703/25418464200_564ea61514_n.jpg" alt="Step3"&gt;&lt;/p&gt;

&lt;p&gt;因為分母 =\= 0, 所以這邊僅需要求分子 &lt;strong&gt;bp - aq- abf = 0&lt;/strong&gt; 的 f 解, 透過移項後即可得到 G(f) 的極值出現在 f 為何時 (當然這邊其實還要用二階微分來求函數的凹性, 確認求出的 f 值代入 G(f) 是極大還是極小值, 但這邊省略請直接參考 &lt;a href="https://www.math.washington.edu/~morrow/336_10/papers/jane.pdf"&gt;Jane 的文獻&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1481/25719324655_119cc96a22_m.jpg" alt="Step4"&gt;&lt;/p&gt;

&lt;p&gt;得到 (式2) 的解後, 就可以知道 (式1) 得到的 Kelly Fromula 僅是當 a 為 1 時的特殊解。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.symbolab.com"&gt;推薦Online好用的數學工具&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="thestockmarket"&gt;The Stock Market&lt;/h2&gt;

&lt;p&gt;股票市場上的賭局並非使用固定的賠率看待, 所以這邊引入了隨機變數的概念, 用 &lt;strong&gt;X&lt;/strong&gt; 表示每單位可拿回的金額 (相當於之前 Kelly Formula 裡的賠率 b), P(X = s) 則表示當 X 為 s 時發生的機率。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://ccckmit.wikidot.com/st:randomvariable"&gt;隨機變數參考網站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;又因為今天在設法求出最佳投注資金比例 f 時, 重點不在於整個市場的機率分佈呈現是如何, 所以對機率分佈上做了以下的假設&lt;/p&gt;

&lt;p&gt;&lt;code&gt;P(X = μ + σ) = P(X = μ − σ) = 0.5 ... (式4)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;μ 為平均值&lt;/li&gt;
&lt;li&gt;σ 為標準差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;而在資金 Y 變化的公式則是由下式表示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Y&lt;sub&gt;n&lt;/sub&gt; = Y&lt;sub&gt;n-1&lt;/sub&gt; (1 + (1-f)r + fX), &lt;em&gt;(r 表示 &lt;strong&gt;未&lt;/strong&gt; 進行投注的資金獲得的報償比例)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;解讀為&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;現有剩餘資金 = 前次剩餘資金*(1 + 未投注市場比例*未投注報償比 + 投注市場比例*投注市場報償比) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當今天進行了 n 次的投注後, 嘗試列出 &lt;strong&gt;現有資金&lt;/strong&gt; 與 &lt;strong&gt;初始資金&lt;/strong&gt; 間的關係, 所以這邊重新做了一次以下的假設, 使得我們經過 n 次投注後得到的總 μ, σ&lt;sup&gt;2&lt;/sup&gt; and r 仍相同 (意味要將 μ, σ&lt;sup&gt;2&lt;/sup&gt; and r 平均分散在 n 次的投注中)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;標準差 σ'
&lt;img src="https://farm2.staticflickr.com/1651/25203896753_b1333171ea_t.jpg" alt="Step5"&gt;
(因為要令 σ'&lt;sup&gt;2&lt;/sup&gt; * n = σ&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回報率 μ'
&lt;img src="https://farm2.staticflickr.com/1692/25830684445_9488841440_t.jpg" alt="Step6"&gt;
(因為要令 μ'* n = μ)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他投資回報率 r'
&lt;img src="https://farm2.staticflickr.com/1565/25200176134_81d6ea1236_t.jpg" alt="Step7"&gt;
(因為要令 r'* n = r)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;將以上的變量代入一開始假設的機率分佈
&lt;img src="https://farm2.staticflickr.com/1506/25200176174_cd81ae121e.jpg" alt="Step8"&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以導出 Y&lt;sub&gt;n&lt;/sub&gt; 與 Y&lt;sub&gt;0&lt;/sub&gt; 的關係式
&lt;img src="https://farm2.staticflickr.com/1579/25202372904_2b2901e3d6_n.jpg" alt="Step9"&gt;&lt;/p&gt;

&lt;p&gt;將 Y&lt;sub&gt;0&lt;/sub&gt; 移項至左式, 再兩邊同取 ln 後
&lt;img src="https://farm2.staticflickr.com/1520/25738035291_dc778d991b.jpg" alt="Step10"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;回到 Kelly Formula 的討論, 我們仍是要求 G&lt;sub&gt;n&lt;/sub&gt;(f) 的極大值出現在 f (資金下注比例) 為何時?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在這部分的推導上是先將 G&lt;sub&gt;n&lt;/sub&gt;(f) 以 Maclaurin 級數展開, 並令 n-&gt;∞ 時對多項式來求極值。&lt;/p&gt;

&lt;p&gt;&lt;a data-flickr-embed="true" href="https://www.flickr.com/photos/138186136@N06/25254483243/in/dateposted-public/" title="Step11"&gt;&lt;img src="https://farm2.staticflickr.com/1550/25254483243_fae5dae26b.jpg" align="center" width="375" height="500" alt="Step11"&gt;&lt;/a&gt;&lt;script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"&gt;&lt;/script&gt; &lt;br&gt;
(詳細的步驟可以參考我的計算過程, 跟 Jane 的有些微出入, 我猜她可能沒有實際推導後面的展開式, 所以才會在微分的結果上寫錯)&lt;/p&gt;

&lt;p&gt;最後我們總算可以導出適用於市場的 Kelly Criterion。
&lt;img src="https://farm2.staticflickr.com/1518/25883526085_a10a0e006e_o.jpg" alt="Step12"&gt;&lt;/p&gt;</content:encoded></item><item><title>海龜特訓班 筆記 (Mind Map)</title><description>&lt;blockquote&gt;
  &lt;p&gt;原名&lt;/p&gt;
  
  &lt;p&gt;The Complete TurtleTrader by &lt;strong&gt;Michael W. Covel&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;這是一部關於 理察.丹尼斯 (Richard Dennis) 訓練雜牌軍成為百萬交易員的故事(1983-1984)。不過絕大部分都被我在筆記中省略了 (笑)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;由來&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;海龜&lt;/strong&gt; 是丹尼斯給學生們的暱稱, 曾到新加坡參觀海龜培育場而受到了啟發, 「要像培育海龜般的那樣培育交易員」。&lt;/p&gt;

&lt;h2 id=""&gt;第一部分&lt;/h2&gt;

&lt;p&gt;回顧歷史的鋪成, 介紹實驗的契機、挑選過程與最後成為交易員的海龜們背景多麼隨機性 (就當故事書讀讀吧)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;無限多猴子理論 (Infinite Monkey Theory)&lt;/p&gt;
  
  &lt;p&gt;只要世界上有無限多個猴子在隨機敲打鍵盤，最後就會有一隻敲出 莎士比亞全集。&lt;/p&gt;
  
  &lt;p&gt;(筆者按: 書中只是提到這個理論, 但無論是 丹尼斯 或是 他的實驗伙伴 艾克哈特 &lt;em&gt;(William Eckhardt)&lt;/em&gt; 都不相信這是巧合帶來實驗的結果)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="mindmap"&gt;第二部分 交易策略 (Mind Map)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用方式類似 Google&lt;/p&gt;&lt;/blockquote&gt;</description><link>http://localhost:2368/hai-gui-te-xun-ban-bi-ji/</link><guid isPermaLink="false">a9e4ea00-cd31-4d7d-923e-76b57ab14b5f</guid><category>順勢</category><category>Richard Dennis</category><category>海龜</category><category>Mind Map</category><category>理查.丹尼斯</category><dc:creator>Captain Vincent</dc:creator><pubDate>Mon, 07 Mar 2016 06:40:10 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;原名&lt;/p&gt;
  
  &lt;p&gt;The Complete TurtleTrader by &lt;strong&gt;Michael W. Covel&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;這是一部關於 理察.丹尼斯 (Richard Dennis) 訓練雜牌軍成為百萬交易員的故事(1983-1984)。不過絕大部分都被我在筆記中省略了 (笑)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;由來&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;海龜&lt;/strong&gt; 是丹尼斯給學生們的暱稱, 曾到新加坡參觀海龜培育場而受到了啟發, 「要像培育海龜般的那樣培育交易員」。&lt;/p&gt;

&lt;h2 id=""&gt;第一部分&lt;/h2&gt;

&lt;p&gt;回顧歷史的鋪成, 介紹實驗的契機、挑選過程與最後成為交易員的海龜們背景多麼隨機性 (就當故事書讀讀吧)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;無限多猴子理論 (Infinite Monkey Theory)&lt;/p&gt;
  
  &lt;p&gt;只要世界上有無限多個猴子在隨機敲打鍵盤，最後就會有一隻敲出 莎士比亞全集。&lt;/p&gt;
  
  &lt;p&gt;(筆者按: 書中只是提到這個理論, 但無論是 丹尼斯 或是 他的實驗伙伴 艾克哈特 &lt;em&gt;(William Eckhardt)&lt;/em&gt; 都不相信這是巧合帶來實驗的結果)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="mindmap"&gt;第二部分 交易策略 (Mind Map)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用方式類似 Google Map 的拖曳操作可以移動畫面, 右鍵可以彈出放大鏡的按鈕, 按壓放大鏡拖曳後可以 Zoom In/Out&lt;/p&gt;
&lt;/blockquote&gt;

&lt;iframe width="853" height="480" src="https://embed.coggle.it/diagram/Vt9MRT9kC8o93lZw/ba20a801476260b3885c5a005c35b6b9ce12bb13d385efd229574892c2083848" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;  

&lt;blockquote&gt;
  &lt;p&gt;在第二屆的學員們中, 提出了當時海龜策略槓桿底下背負的風險, 遠比老師 丹尼斯 設想的要高上許多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;第三部分&lt;/h2&gt;

&lt;p&gt;實驗展開地後續, 在不平等的交易配額下導致內部崩裂、交易員間的猜忌; 而在混沌之中, 丹尼斯的交易身影也在一場公募基金的災難中退下舞台。&lt;/p&gt;

&lt;h2 id=""&gt;故事尾聲&lt;/h2&gt;

&lt;p&gt;敘述著 丹尼斯 及 海龜們 在各自離開之後的發展, 這中間有許多的風光但也有著些許唏噓, 並在受訪之後為我們留下分析、談論著他們之間為何誰才會是贏家的觀點, 畢竟在他們分道揚鑣後, 我們得從規則以外找些別的東西, 來區分是何能讓脫穎而出的人達到長期交易的成功並得以延續發光, 這邊列出書中提到的幾點 &lt;strong&gt;需保持心理強韌、具備企業家精神&lt;/strong&gt;, 也許就是這樣的人, 才能夠繼續把握機會順勢操盤人生的吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;企業家精神 (書中整理, 由Nancy Upton 及  Don Sexton 提出)&lt;/p&gt;
  
  &lt;ul&gt;
  &lt;li&gt;不妥協者：較低的妥協需求, 自立自強&lt;/li&gt;
  &lt;li&gt;情緒冷淡者：對人不一定冷漠, 不過也可能很明顯&lt;/li&gt;
  &lt;li&gt;高空跳傘者：比較不在意身體受傷, 但此特質會隨年齡改變&lt;/li&gt;
  &lt;li&gt;冒險者：喜歡冒險&lt;/li&gt;
  &lt;li&gt;社交圓滑者：比較具說服力&lt;/li&gt;
  &lt;li&gt;獨立自主：有較高的自立需求&lt;/li&gt;
  &lt;li&gt;求變者：喜歡新奇的方法&lt;/li&gt;
  &lt;li&gt;充滿活力：較需要且能較長時間工作&lt;/li&gt;
  &lt;li&gt;自我滿足：不需要他人認同, 但還是要組成人脈&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title>21st Century C / 21世紀 C 語言 (閱讀筆記)</title><description>&lt;blockquote&gt;
  &lt;p&gt;C 語言的演進, K&amp;amp;R (1978) -&gt; ANSI C89 (1989) -&gt; ISO C99 (1999) -&gt; C11 (2011)&lt;/p&gt;
  
  &lt;p&gt;POSIX (&lt;strong&gt;P&lt;/strong&gt;ortable &lt;strong&gt;O&lt;/strong&gt;perating &lt;strong&gt;S&lt;/strong&gt;ystem &lt;strong&gt;I&lt;/strong&gt;nterface of UNI&lt;strong&gt;X&lt;/strong&gt;) 標準, 由 IEEE 制定類  Unix 的作業系統在實作上共通的基礎 (API 的關聯、Shell的運作、命令列工具的的執行相關規範, 跟本篇最大的關聯是符合 POSIX 標準的系統, 也包含了提供 C 語言的編譯器)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;介紹內容&lt;/h2&gt;

&lt;p&gt;Basic Tool: GDB、Valgrind、&lt;/p&gt;</description><link>http://localhost:2368/21st-century-c/</link><guid isPermaLink="false">baa7b733-a6a7-466e-b381-2efbfd401ea0</guid><category>GDB</category><category>Valgrind</category><category>Gprof</category><category>Make</category><category>pkg-config</category><category>doxygen</category><dc:creator>Captain Vincent</dc:creator><pubDate>Fri, 04 Mar 2016 13:04:20 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;C 語言的演進, K&amp;amp;R (1978) -&gt; ANSI C89 (1989) -&gt; ISO C99 (1999) -&gt; C11 (2011)&lt;/p&gt;
  
  &lt;p&gt;POSIX (&lt;strong&gt;P&lt;/strong&gt;ortable &lt;strong&gt;O&lt;/strong&gt;perating &lt;strong&gt;S&lt;/strong&gt;ystem &lt;strong&gt;I&lt;/strong&gt;nterface of UNI&lt;strong&gt;X&lt;/strong&gt;) 標準, 由 IEEE 制定類  Unix 的作業系統在實作上共通的基礎 (API 的關聯、Shell的運作、命令列工具的的執行相關規範, 跟本篇最大的關聯是符合 POSIX 標準的系統, 也包含了提供 C 語言的編譯器)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;介紹內容&lt;/h2&gt;

&lt;p&gt;Basic Tool: GDB、Valgrind、gprof、make、pkg-config、doxygen &lt;br&gt;
Autotools: Autoconf、Automake、libtool &lt;br&gt;
Useful Lib: libcURL、libGlib、libGSL、libSQLite3、libXML2&lt;/p&gt;

&lt;h4 id=""&gt;編譯階段&lt;/h4&gt;

&lt;p&gt;使用 pkg-config 顯示出使用該lib需要的 include、link 參數&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;pkg-config --libs [lib name]  
pkg-config --cflags [lib name]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;一般在編譯時, 使用額外 lib 在編譯時所需的下參數&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- lnaguage-bash"&gt;gcc -I[header path] -L[library path] -l[library name]  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;-I: 將路徑加入 include header 搜尋 path&lt;/li&gt;
&lt;li&gt;-L: 將路徑加入 Library 搜尋 path&lt;/li&gt;
&lt;li&gt;-l: 指定連結函式庫&lt;/li&gt;
&lt;li&gt;-D: 等同於 define symbol (ex. -Dxxx)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以搭配 pkg-config 使用 (但並非所有 lib 都有對 pkg-config 註冊)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;gcc ｀pkg-config --cflags --libs [lib name]` -o [output name] [source file name]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="linksharelibrary"&gt;執行期間的 Link  (Share Library)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用 Autotools, Libtool 會自動加入正確的旗標來搜尋使用的 lib (後面章節會介紹)&lt;/li&gt;
&lt;li&gt;透過 export LD_LIBRARY_PATH 來指定執行時的搜尋路徑&lt;/li&gt;
&lt;li&gt;在 makefile 中添加 &lt;code&gt;LDADD=-L[lib path] -Wl, -R[lib path]&lt;/code&gt; 
(-Wl 用來將後續用'逗號'隔開的 list 轉換成'空白'的 list 後傳給 linker)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h4 id="makefile"&gt;使用 Makefile 簡化編譯時冗長繁瑣的指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class="language- language-makefile"&gt;P=program_name  
OBJECT=  
CFLAGS= -g -Wall -O3  
LDLIBS=  
CC=C99

$(P): $(OBJECT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Makefile 範例)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$(var name) 表示變數, Shell使用 $Var 而 Makefile則要求必須以小括號括起來&lt;/li&gt;
&lt;li&gt;以冒號 ":" 區隔表示相依的關係&lt;/li&gt;
&lt;li&gt;以上的變數會在 make 的隱含規則中展開成執行的命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;除了上述範例中, 將變數值直接宣告在 Makefile 內, 額外將變數值傳給 Makefile 的方式有&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;export 進環境變數  &lt;/li&gt;
&lt;li&gt;將變數指派命令放在執行命令之前 (只限當次執行有效) &lt;br&gt;
&lt;em&gt;C 語言編譯的程式, 可在程式碼中透過 getenv 取得 1. 或 2. 指定的值&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;make 也允許從命令列設定變數&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;CFLAGS="-g -Wall" make // 針對 make 及 子程序設定環境變數 (上述方法2)  
make CFLAGS="-g -Wall" // 設定 makefile 變數 (上述方法3)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;make -p &amp;gt; rule.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以查看 rule.txt 了解 make 的隱含規則&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Manual Page&lt;/p&gt;
  
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;man 指令可以搜尋函式的使用手冊 (ex. &lt;code&gt;man printf&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;code&gt;man -k keyword&lt;/code&gt; 可以搜尋簡介&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;manual 分許多 section, section 1 為命令列、3為函式庫名稱 (man 3 printf 會列出 C 函式庫的文件)&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;vi 可將游標移到 keyword 上, 按 &lt;strong&gt;K&lt;/strong&gt; 查閱 manual page&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/Here%E6%96%87%E6%A1%A3"&gt;Here文檔的介紹&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="debug"&gt;Debug / 除錯&lt;/h4&gt;

&lt;p&gt;&lt;a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html"&gt;GDB vs LLDB&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;set $ptr=&amp;amp;x[3] //expr int* $ptr = &amp;amp;x[3]  
p *($ptr++)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之後再重複按 &lt;code&gt;Enter&lt;/code&gt; 會執行前一動指令, 此技巧可走訪陣列, 甚至套用 link-list&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;p $  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$ 可表示前一次輸出變數存放的值, 但這邊 LLDB 測試無效&lt;/p&gt;

&lt;p&gt;在 .gdbinit 中可以 define macro 來整理複雜資料結構的輸出&lt;/p&gt;

&lt;h6 id="profiling"&gt;Profiling&lt;/h6&gt;

&lt;p&gt;Compile option 加上 &lt;code&gt;-pg&lt;/code&gt; 會為 gprof 準備程式, 指令 &lt;code&gt;gprof binary &amp;gt; profile&lt;/code&gt; 即可開始記錄, 結束後再打開 profile 看 log。 &lt;br&gt;
mac 上的分析可以參考 &lt;a href="http://stackoverflow.com/questions/11445619/profiling-c-on-mac-os-x"&gt;StackOverflow 提到的 Instruments&lt;/a&gt;&lt;/p&gt;

&lt;h6 id="valgrind"&gt;Valgrind&lt;/h6&gt;

&lt;p&gt;可以使用 Valgrind 偵測記憶體的使用錯誤(例子省略)&lt;/p&gt;

&lt;h6 id="unittest"&gt;Unit Test&lt;/h6&gt;

&lt;p&gt;使用 Glib 內建的 tool 來實作(省略), 求覆蓋率可透過在 Compile option 加上 &lt;br&gt;
&lt;code&gt;- fprofile-arcs -ftest-coverage -O0&lt;/code&gt;, 在執行程式後下指令 &lt;code&gt;gcov program.gcda&lt;/code&gt; 可顯示執行行數的百分比, 另外 program.c.cov 會顯示被測試到的次數&lt;/p&gt;

&lt;h6 id="doxygen"&gt;Doxygen&lt;/h6&gt;

&lt;p&gt;使用 Doxygen 來產生文件, 比起在程式碼中添加的說明, 搭配 Graphviz 產生的各類圖表在 trace code 幫助更大。&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="autotool"&gt;Autotool 章節&lt;/h4&gt;

&lt;p&gt;在打包程式的部分目前常見的還有 CMake 可以使用, autotool的部分等以後有時間再回過頭來看吧... Ker Ker&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="git"&gt;Git 版本控管章節&lt;/h4&gt;

&lt;p&gt;&lt;a href="https://git-scm.com/book/zh-tw/v1"&gt;Git 中文參考資料&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id=""&gt;類似書中範例的參考&lt;/h4&gt;

&lt;p&gt;&lt;a href="http://intermediate-and-advanced-software-carpentry.readthedocs.org/en/latest/c++-wrapping.html"&gt;Wrapping C/C++ for Python&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id=""&gt;變數的存取&lt;/h4&gt;

&lt;p&gt;&lt;a href="http://www.csee.umbc.edu/courses/undergraduate/202/spring07/Lectures/ChangSynopses/modules/m05-scope/slides.php?print"&gt;Reference&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Life Time
&lt;ul&gt;&lt;li&gt;static: 直到程式結束為止才會釋放&lt;/li&gt;
&lt;li&gt;automatic: 離開 Scope (block) 的時候即會馬上釋放&lt;/li&gt;
&lt;li&gt;dynamic: 要手動 free 才會釋放&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scope
&lt;ul&gt;&lt;li&gt;Local scope: 在 block 內可被看見&lt;/li&gt;
&lt;li&gt;Class scope: Class 內的成員才可看見&lt;/li&gt;
&lt;li&gt;Namespace scope: 同一個 namespace 才可看見&lt;/li&gt;
&lt;li&gt;File scope: 相同檔案內才可看見&lt;/li&gt;
&lt;li&gt;Global scope: 任何地方皆可看見, 除非被隱藏&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="structvsarray"&gt;Struct vs Array&lt;/h6&gt;

&lt;p&gt;在記憶體的使用上, 傳遞 struct 時會整個被複製出去, 但 array 僅會傳遞別名 (指向相同的記憶體空間)。&lt;/p&gt;

&lt;p&gt;另外, Array 目前已可提供執行期才決定大小 (透過 run time 得知的值來宣告 array), 並且不用手動 free。&lt;/p&gt;

&lt;h6 id="point"&gt;Point&lt;/h6&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;ptr[0] = *(ptr+0) // 這邊僅表示左右兩者相等, 非賦值  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(但是 void 的 point 是無法以陣列的方式取值, 因為缺少了型別無法計算位移量)。&lt;/p&gt;

&lt;h6 id="nan"&gt;NaN&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;N&lt;/strong&gt;ot-&lt;strong&gt;A&lt;/strong&gt;-&lt;strong&gt;N&lt;/strong&gt;umber, 使用 NaN 作為例外回傳值, 另外 NaN 具備的特性, 即使 &lt;code&gt;NaN == NaN&lt;/code&gt; 也會回傳 false, 只能用 &lt;code&gt;isnan()&lt;/code&gt; 來檢查。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NaN 的值可透過 0/0. 來得到 (0/0 會產生錯誤, 因為整數無法表示 NaN)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;h4 id=""&gt;介紹容易犯錯的章節&lt;/h4&gt;

&lt;h6 id="macro"&gt;Macro&lt;/h6&gt;

&lt;p&gt;在巨集的外部需加上大括號, 好處是可限制展開內容的變數生存空間, 也可降低展開後造成問題的風險。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;gcc -E [source file name]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上 &lt;code&gt;-E&lt;/code&gt; option 之後只會執行前置處理器的部分, 並從標準輸出中印出結果, 可搜尋巨集擴展的部分來除錯。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;前置處理器中的小技巧&lt;/p&gt;
  
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;如果有兩個連續的字串出現, 箝制處理器會將兩個字串合併為一個&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;code&gt;sizeof()&lt;/code&gt; 是個 compile time 的 operator&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h6 id="const"&gt;const&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;int const : 常數整數&lt;/li&gt;
&lt;li&gt;int const * : 一個可變動的指標, 指向常數整數&lt;/li&gt;
&lt;li&gt;int * const : 一個常數指標, 指向可變動的整數&lt;/li&gt;
&lt;li&gt;int * const * : 一個指向常數指標的指標&lt;/li&gt;
&lt;li&gt;int const * * : 一個指標的指標, 指向常數整數&lt;/li&gt;
&lt;li&gt;int const * const * : 一個指向常數指標的指標, 常數指標指向常數整數


&lt;blockquote&gt;
  &lt;p&gt;前後相鄰的 int 與 const 可以互換, 意義仍不變。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
  &lt;/ul&gt;
  struct 內的變數, 透過將 pointer 傳出之後仍舊無法受到 const 的保護, 需特別注意。 &lt;p&gt;&lt;/p&gt;


&lt;pre&gt;&lt;code class="language- language-clike"&gt;int *ptr;  
int const **constptr = &amp;amp;ptr  
int const const_var = 10;  
*constprt = &amp;amp;const_var // 等同 ptr = &amp;amp;const_var
*prt = 20 // 等同於改變了 const_var 的值
&lt;/code&gt;&lt;/pre&gt;


範例顯示透過指標操作 const 需要小心



&lt;hr&gt;




&lt;h4 id=""&gt;好用工具介紹&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;asprintf 來做文字轉換 (函式會自行 malloc, 但需手動 free)&lt;/li&gt;
&lt;li&gt;Stopif 巨集的使用可在函式 return 異常值時提供保護&lt;/li&gt;
&lt;li&gt;strdup 可以回傳複製字串後的內容&lt;/li&gt;
&lt;li&gt;strtok 以 strtok_r or strtok_s 取代 (thread safe)&lt;/li&gt;
&lt;li&gt;mmap 可以解決讀取檔案比記憶體大的問題&lt;/li&gt;
&lt;li&gt;libxml 提供處理 unicode 的函式庫
&lt;ul&gt;&lt;li&gt;語言相關處理的 keywords : Gettext 提供翻譯框架、xgettext 產生需要翻譯的字串索引&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h4 id=""&gt;特殊技巧&lt;/h4&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;define test(i, ...) for(int index=0; index&amp;lt;i; i++) {__VA__ARGS__}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;展開時, 在第二個參數之後 (從 &lt;code&gt;...&lt;/code&gt; 刪節號之後的參數都會被展開至 &lt;code&gt;__VA__ARGS__&lt;/code&gt; 的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;int iArray[] = {0, 1, 2, 3}; //賦值用  
function( (iArray[]){0,1,2,3} ) //傳遞用  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;複合常量的寫法&lt;/li&gt;
&lt;li&gt;透過前兩項技巧可以寫出向量化的 macro (展開成多個處理相同事情的 Snippets)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;struct stTest  
{
    int first;
    int second;
};
struct stTest temp = {.first=1};  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;int list[5] = {[3]=4, [4]=5};  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;指定初始子, 未指定會賦值 0&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;__attribute__((format(printf,m,n)))  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用 __attribute__ 來控制變量輸入的問題, &lt;a href="http://huenlil.pixnet.net/blog/post/26078382-%5B%E8%BD%89%5Dgnu-c-__attribute__-%E6%A9%9F%E5%88%B6%E7%B0%A1%E4%BB%8B"&gt;參考資訊&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(最後兩章的翻譯讀起來有點怪, 加上應用層面比較難參考, 就整理到這邊吧 : ) 收工~)&lt;/p&gt;</content:encoded></item><item><title>Python 第一步 virtualenv</title><description>&lt;p&gt;剛開始接觸 Python 的時候, 最先了解到的是開發者社群的貢獻, 有別於 C/C++ 這類型語言給我的感覺, 在開發上使用第三方的函式庫, 是相當方便以及普遍的事情。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;a href="https://pypi.python.org/pypi"&gt;Python Package Index (PyPI)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;PyPI is the default Package Index for the Python community. It is open to all Python developers to consume and distribute their distributions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;早期 Python 在套件的安裝上有數種工具可以選擇, 不過目前比較主流的是透過 &lt;strong&gt;PIP&lt;/strong&gt; 來安裝套件 (搜尋、安裝已經建立在 PyPI 上的套件), 這邊會先建議在開始安裝其它套件之前, 可以先安裝名為 &lt;strong&gt;virtualenv&lt;/strong&gt;&lt;/p&gt;</description><link>http://localhost:2368/python-xin-shou-ru-men/</link><guid isPermaLink="false">2f5401a3-206c-4e83-9d88-7cbc63958609</guid><category>python</category><category>pip</category><category>virtualenv</category><dc:creator>Captain Vincent</dc:creator><pubDate>Wed, 24 Feb 2016 18:07:00 GMT</pubDate><content:encoded>&lt;p&gt;剛開始接觸 Python 的時候, 最先了解到的是開發者社群的貢獻, 有別於 C/C++ 這類型語言給我的感覺, 在開發上使用第三方的函式庫, 是相當方便以及普遍的事情。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;a href="https://pypi.python.org/pypi"&gt;Python Package Index (PyPI)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;PyPI is the default Package Index for the Python community. It is open to all Python developers to consume and distribute their distributions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;早期 Python 在套件的安裝上有數種工具可以選擇, 不過目前比較主流的是透過 &lt;strong&gt;PIP&lt;/strong&gt; 來安裝套件 (搜尋、安裝已經建立在 PyPI 上的套件), 這邊會先建議在開始安裝其它套件之前, 可以先安裝名為 &lt;strong&gt;virtualenv&lt;/strong&gt;, 這個用來建立獨立 python 執行環境的套件, 之後就可以愉快體驗 &lt;del&gt;也不用擔心系統髒髒的&lt;/del&gt;。&lt;/p&gt;

&lt;p&gt;安裝方式很簡單, 如下&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;pip install virtualenv  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先透過 pip 安裝 virtualenv, 安裝完後可以執行的命令如下&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;virtualenv [ENVNAME]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在當前目錄底下建立一個資料夾, 裡面會存放可獨立運行的 python 執行環境&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;cd [ENVNAME]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移動至該路徑下&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;source bin/activate  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;啟用這個執行環境, 啟用後的效果包含之後安裝的套件會在此路徑下, 以及執行的 python 程式會使用此路徑下的 library&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;deactivate  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用完畢後可以退出這個虛擬環境, 嗯~ 系統除了多了這個工作路徑的資料夾其他依舊美好。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;補充&lt;/p&gt;
  
  &lt;p&gt;在虛擬環境的管理上其實也有套件可以幫忙, 好處是不會讓建立虛擬環境的資料夾分散在各處 (集中放置)、切換流程更加便利, 這邊要介紹的就是透過 &lt;a href="http://virtualenvwrapper.readthedocs.org/en/latest/index.html"&gt;&lt;strong&gt;virtualenvwrapper&lt;/strong&gt;&lt;/a&gt; 來處理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;pip install virtualenvwrapper  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安裝套件方式一樣是透過 pip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export WORKON_HOME=$HOME/PyEnv  
export PROJECT_HOME=$HOME/Devel  
source /usr/local/bin/virtualenvwrapper.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將以上貼入 .bashrc or .zshrc 檔 (是根據你所使用的 Shell 預設會開啟時會載入的 rc 檔)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WORKON_HOME 是虛擬環境配置的路徑&lt;/li&gt;
&lt;li&gt;PROJECT_HOME 暫時用不到&lt;/li&gt;
&lt;li&gt;最後 source 腳本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;介紹常用的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;mkvirtualenv [-i package] [-r requirements_file] [virtualenv options] [ENVNAME]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立虛擬環境&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;lsvirtualenv [-b] [-l] [-h]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出存在的虛擬環境&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;rmvirtualenv [ENVNAME]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除虛擬環境&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;$ workon [ENVNAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;啟動虛擬環境&lt;/p&gt;

&lt;p&gt;最後退出虛擬環境的方式一樣是用 &lt;code&gt;deactivate&lt;/code&gt;。&lt;/p&gt;</content:encoded></item><item><title>MT4</title><description>&lt;blockquote&gt;
  &lt;p&gt;MT4 (&lt;a href="http://www.metatrader4.com/"&gt;Metatrade 4&lt;/a&gt;) 以及 MT5 (&lt;a href="http://www.metatrader5.com/"&gt;Metatrade 5&lt;/a&gt;) 都是由俄羅斯公司 MetaQuotes Software Corp 所開發的交易平台, 並由各個外匯公司對該平台提供服務。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;MQL4  
|-- Experts (EA 又稱專家系統, 執行交易策略的文件)
|-- Files (程式中使用到的外部檔案)
|-- Images (程式中使用的點陣圖)
|-- Include (Header檔)
|-- Indicators (建立指標的文件)
|-- Libraries
|-- Logs
|-- Presets (預設屬性區)
|-- Projects
`-- Scripts (腳本檔)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;檔案存放路徑結構&lt;/p&gt;

&lt;p&gt;MQL4/MQL5 為該交易平台所撰寫的程式語言, 語法的部分類似 C/C+&lt;/p&gt;</description><link>http://localhost:2368/mt4/</link><guid isPermaLink="false">b3f6f3fb-3745-41fa-b9de-7efcec901737</guid><category>MT4</category><category>MQL4</category><category>外匯</category><category>自動交易</category><category>程式</category><dc:creator>Captain Vincent</dc:creator><pubDate>Wed, 24 Feb 2016 09:18:15 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;MT4 (&lt;a href="http://www.metatrader4.com/"&gt;Metatrade 4&lt;/a&gt;) 以及 MT5 (&lt;a href="http://www.metatrader5.com/"&gt;Metatrade 5&lt;/a&gt;) 都是由俄羅斯公司 MetaQuotes Software Corp 所開發的交易平台, 並由各個外匯公司對該平台提供服務。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;MQL4  
|-- Experts (EA 又稱專家系統, 執行交易策略的文件)
|-- Files (程式中使用到的外部檔案)
|-- Images (程式中使用的點陣圖)
|-- Include (Header檔)
|-- Indicators (建立指標的文件)
|-- Libraries
|-- Logs
|-- Presets (預設屬性區)
|-- Projects
`-- Scripts (腳本檔)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;檔案存放路徑結構&lt;/p&gt;

&lt;p&gt;MQL4/MQL5 為該交易平台所撰寫的程式語言, 語法的部分類似 C/C++ (筆者的感覺其實只是 C/C++ 的子集, 所以有學過 C/C++的人應該不太陌生), 故詳細語法在這邊不是著墨的重點。&lt;/p&gt;

&lt;h2 id="mql45"&gt;MQL4/5 撰寫的程式碼用途&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;EA 連結至特定圖表後的自動交易系統, 可用於回測&lt;/li&gt;
&lt;li&gt;Indicators 編寫透過自訂公式來計算數據產生的指標&lt;/li&gt;
&lt;li&gt;Scripts 執行單一功能的程式碼, 附加至圖表時會立即執行一次&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="mql4c"&gt;MQL4 語法與標準 C 不同之處&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;  &lt;/p&gt;

&lt;h6 id="datatypehttpsdocsmql4combasistypes"&gt;&lt;strong&gt;&lt;a href="https://docs.mql4.com/basis/types"&gt;Data Type&lt;/a&gt;&lt;/strong&gt; (範例皆轉自官方)&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;string svar="This is a character string";  
string svar2=StringSubstr(svar,0,4);  
Print("Copyright symbol\t\x00A9");  
FileWrite(handle,"This string contains a new line symbols \n");  
string MT4path="C:\\Program Files\\MetaTrader 4";  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;color&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;//--- Literals
C'128,128,128'    // Gray  
C'0x00,0x00,0xFF' // Blue  
//color names
clrRed               // Red  
clrYellow            // Yellow  
clrBlack             // Black  
//--- Integral representations
0xFFFFFF          // White  
16777215          // White  
0x008000          // Green  
32768             // Green  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Datetime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;datetime NY=D'2015.01.01 00:00';     // Time of beginning of year 2015  
datetime d1=D'1980.07.19 12:30:27';  // Year Month Day Hours Minutes Seconds  
datetime d2=D'19.07.1980 12:30:27';  // Equal to D'1980.07.19 12:30:27';  
datetime d3=D'19.07.1980 12';        // Equal to D'1980.07.19 12:00:00'  
datetime d4=D'01.01.2004';           // Equal to D'01.01.2004 00:00:00'  
datetime compilation_date=__DATE__;             // Compilation date  
datetime compilation_date_time=__DATETIME__;    // Compilation date and time  
datetime compilation_time=__DATETIME__-__DATE__;// Compilation time  
//--- Examples of declarations after which compiler warnings will be returned
datetime warning1=D'12:30:27';       // Equal to D'[date of compilation] 12:30:27'  
datetime warning2=D'';               // Equal to __DATETIME__  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h6 id="preprocessor"&gt;&lt;strong&gt;提供 Preprocessor 對程式屬性的設定&lt;/strong&gt;&lt;/h6&gt;

&lt;p&gt;&lt;a href="https://docs.mql4.com/basis/preprosessor/compilation"&gt;#Properties&lt;/a&gt; (參考官方介紹)&lt;/p&gt;

&lt;h2 id="mql4"&gt;MQL4 程式介紹&lt;/h2&gt;

&lt;h4 id=""&gt;報價系統跳動單位&lt;/h4&gt;

&lt;p&gt;外匯交易單位為一手 (部份券商交易提供較小單位的操作 ex. 0.1手、0.01手), 而這邊一手實際上指的是交易量 (而非價) 的單位, &lt;strong&gt;一手表示為 100K 單位貨幣&lt;/strong&gt; (依前方的貨幣為主 ex. 一手 EURUSD 的單, 金額為 100K EUR)&lt;/p&gt;

&lt;p&gt;而在外匯交易的報價是以點 (Pips) 為跳動單位, 但在程式交易內的跳動則是用 Points 來替代, 包含允許滑點 (Slippage) 的參數也都是以 Points 來設定, 但 Points 在各券商報價系統中實際為何不一定 (如果報價單位有提供到步 則 1 Point = 1步, 若只有到點 則 1 Points = 1點)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pips 稱 &lt;strong&gt;點&lt;/strong&gt;, 而比 Pips 再小一位數的單位則稱 &lt;strong&gt;小點&lt;/strong&gt; 或是 &lt;strong&gt;步&lt;/strong&gt; (1點 = 10步)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=""&gt;下單種類&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;市價單 (OP&lt;em&gt;BUY, OP&lt;/em&gt;SELL)&lt;/li&gt;
&lt;li&gt;順勢單 (OP&lt;em&gt;BUYSTOP, OP&lt;/em&gt;SELLSTOP)
超過指定價格買 BUY單 或 SELL單 (不保證履約價)&lt;/li&gt;
&lt;li&gt;逆勢單 (OP&lt;em&gt;BUYLIMIT, OP&lt;/em&gt;SELLLIMIT) 成交價在限制價格內才會買進 (會保證成交價)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(外匯券商所允許的下單方式為)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;現價以上, 可以下 Buy-Stop, Sell-Limit&lt;/li&gt;
&lt;li&gt;現價以下, 可以下 Buy-Limit, Sell-Stop
&lt;img src="https://farm2.staticflickr.com/1577/25187105571_52e4ff737f.jpg" alt=""&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=""&gt;&lt;strong&gt;特殊函數&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href="https://docs.mql4.com/basis/function/events"&gt;More Detail&lt;/a&gt; (參考官方介紹)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OnInit()－程式起始時會執行一次&lt;/li&gt;
&lt;li&gt;OnTick()－圖表 Event 會觸發執行的函式&lt;/li&gt;
&lt;li&gt;OnTimer()－時間 Event 會觸發執行的函式&lt;/li&gt;
&lt;li&gt;OnDeinit()－結束時會執行的函式&lt;/li&gt;
&lt;li&gt;OnTester()－測試 Event 會觸發執行的函式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="index"&gt;&lt;strong&gt;關於時序物件的 Index&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;當前的物件皆為 ０, 時間愈往倒退值愈大
ex. 收盤價, 今日為 Close[0], 昨日為 Close[1]...etc&lt;/p&gt;

&lt;h4 id="api"&gt;&lt;strong&gt;交易 API 介紹&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;這邊介紹一些關於撰寫 EA 時會經常使用到的 API&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order Send&lt;/strong&gt; : 下單 API, 預掛單也是透過此 API&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;OrderSend( str symbol, int cmd=OP_BUY|OP_SELL|OP_BUYSTOP|OP_SELLSTOP|OP_BUYLIMIT|OP_SELLLIMIT, dbl volume, dbl price, int slippage, dbl stoploss, dbl takeprofit, str comment=NULL, int magic=0, dtt expiration=0, clr arrow_color=CLR_NONE )  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CMD - 顧名思義, 下單可執行的操作 (四種下單操作)&lt;/li&gt;
&lt;li&gt;Volume - 幾手 (外匯下單的單位)&lt;/li&gt;
&lt;li&gt;Price - 價位&lt;/li&gt;
&lt;li&gt;Slippage - 允許最大滑點&lt;/li&gt;
&lt;li&gt;Stop Loss - 停損價位&lt;/li&gt;
&lt;li&gt;Take Profit - 停利價位&lt;/li&gt;
&lt;li&gt;Comment - 註解&lt;/li&gt;
&lt;li&gt;Magic - 訂單識別碼&lt;/li&gt;
&lt;li&gt;DTT Expiration - 此單的有效期, 大部分交易商取消&lt;/li&gt;
&lt;li&gt;Arrow Color - 標記在走勢圖上的下單點, &lt;a href="https://docs.mql4.com/constants/objectconstants/webcolors"&gt;顏色參考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Order Modify&lt;/strong&gt; : 修改訂單的 API&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-clike"&gt;OrderModify( int ticket, dbl price, dbl stoploss, dbl takeprofit, dtt expiration, clr color=CLR_NONE )  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="ea"&gt;&lt;strong&gt;EA 程式架構&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;(待補充)&lt;/p&gt;</content:encoded></item><item><title>Sublime Text 教學</title><description>&lt;blockquote&gt;
  &lt;p&gt;筆者按: 網路上關於 Sublime 的教學其實已經多如繁星, 所以本篇說為教學, 充其量目的也只是敝人的備忘錄而已 (笑)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=""&gt;引言&lt;/h4&gt;

&lt;p&gt;在前公司待了三年多快四年, 一直都是在 Windows 上透過 SSH 連到 Linux 的 build server 做開發, 常使用的語言為 C++、C, 而在前公司最普遍的 trace code 工具是有名的 &lt;del&gt;Source Insight&lt;/del&gt;, 但對我來說有以下的缺點:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;非跨平台&lt;/strong&gt; &lt;br&gt;
我個人電腦使用的環境是 OSX, 所以對於開發工具需在公司跟家裡做切換, 使用的意願上其實是非常低, 不外乎在工具的使用也是有所謂的學習曲線, 需分散心力來維持兩套是滿浪費精力的。
(要在 Mac 上執行 Windows 程式就我所知也有三種方式, 一種是安裝雙系統共存, 再來是使用虛擬機器VMWare, 最後則是透過 Wine 來安裝, 但會喜歡使用 Mac 的人其實對優雅都有種偏執, 所以我想還是能省則省吧!&lt;/li&gt;&lt;/ol&gt;</description><link>http://localhost:2368/sublime-jiao-xue/</link><guid isPermaLink="false">4c4675c9-609b-459f-87e2-f2eb84fcd1b9</guid><category>Sublime</category><category>PackageControl</category><dc:creator>Captain Vincent</dc:creator><pubDate>Mon, 22 Feb 2016 18:24:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;筆者按: 網路上關於 Sublime 的教學其實已經多如繁星, 所以本篇說為教學, 充其量目的也只是敝人的備忘錄而已 (笑)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=""&gt;引言&lt;/h4&gt;

&lt;p&gt;在前公司待了三年多快四年, 一直都是在 Windows 上透過 SSH 連到 Linux 的 build server 做開發, 常使用的語言為 C++、C, 而在前公司最普遍的 trace code 工具是有名的 &lt;del&gt;Source Insight&lt;/del&gt;, 但對我來說有以下的缺點:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;非跨平台&lt;/strong&gt; &lt;br&gt;
我個人電腦使用的環境是 OSX, 所以對於開發工具需在公司跟家裡做切換, 使用的意願上其實是非常低, 不外乎在工具的使用也是有所謂的學習曲線, 需分散心力來維持兩套是滿浪費精力的。
(要在 Mac 上執行 Windows 程式就我所知也有三種方式, 一種是安裝雙系統共存, 再來是使用虛擬機器VMWare, 最後則是透過 Wine 來安裝, 但會喜歡使用 Mac 的人其實對優雅都有種偏執, 所以我想還是能省則省吧!)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用介面非常醜&lt;/strong&gt; &lt;br&gt;
這可能主觀意識成分居多, 而且多半應該是來自一種對於 Windows 視窗樣式的厭惡吧! 但気持ち (Kimochi) 有時也是這麼重要～ (攤)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要$$&lt;/strong&gt; &lt;br&gt;
&lt;del&gt;雖然公司都...&lt;/del&gt;, 嗯, 我什麼都沒說。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;笨重&lt;/strong&gt; &lt;br&gt;
匯入專案以及建立 Source tree 需要滿長的時間 (尤其是龐大的專案時), 加上使用起來一直有種跟不上思緒的頓感 (&lt;del&gt;哈味&lt;/del&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模糊搜尋做得不夠好&lt;/strong&gt; &lt;br&gt;
小弟記憶力一直不太好, 所以這功能也滿在意的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最後當工作快滿一年的時候, 經由一位快離職的同事分享, 開始認識了 Sublime, 也就一直擁抱到現在了。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="step1installsublime"&gt;Step 1. Install Sublime&lt;/h2&gt;

&lt;p&gt;首先可以先至官網抓取最新的版本 &lt;a href="http://www.sublimetext.com/2"&gt;Sublime2&lt;/a&gt;、&lt;a href="http://www.sublimetext.com/3"&gt;Sublime3&lt;/a&gt;, 跟一般平台上的應用程式安裝方式無異 (所以這邊省略讓各位自行摸索一下), 接著要 &lt;strong&gt;安裝最重要的套件 Package Control x3&lt;/strong&gt; (筆者懶得打三遍, 但希望你們明白這真的很重要!), 有點類似 Ubuntu 的 apt-get、Mac 的 Homebrew、Python 的 Pip、Node.js 的 npm 關係, 這是一個屬於 Sublime 套件管理的 Plugin (由於實在太方便了, 沒意外的話應該是每個用戶必先安裝, &lt;del&gt;除非天生反骨&lt;/del&gt;)。&lt;/p&gt;

&lt;h2 id="step2installpackagecontrol"&gt;Step 2. Install Package Control&lt;/h2&gt;

&lt;p&gt;Package Control的安裝方式也很簡易 &lt;a href="https://packagecontrol.io/installation"&gt;Package Control安裝頁面&lt;/a&gt; 有提供 Sublime Text 2 跟 Sublime Text 3 的 Command, 執行 Sublime 後按 &lt;code&gt;Ctrl + `&lt;/code&gt; (`是鍵盤最左上角那個) 叫出 Sublime 的 Console Panel (或是透過操作畫面上方的 Menu 選單 &lt;code&gt;View -&amp;gt; Show Console&lt;/code&gt; 也可以叫出)&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1513/24572921463_63fa373e0d.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;複製貼上你下載版本的指令進去按 &lt;code&gt;Enter&lt;/code&gt; 即可 (注意不要複製到行尾或行頭多餘空白格), 安裝完成之後可以再按一次按 &lt;code&gt;Ctrl + `&lt;/code&gt; 或是 &lt;code&gt;ESC&lt;/code&gt; 關掉Console。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1704/24569074674_1c37755a8d_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;此時已經可以執行 Package Control 的相關指令, 方式一樣是兩種 (這部分的操作很頻繁, 所以筆者平時都是以快速鍵操作為主)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;透過操作畫面上方的 Menu 選單 &lt;code&gt;Sublime Text -&amp;gt; Preference -&amp;gt; Package Control&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;按 &lt;code&gt;Ctrl/Cmd(Windows/Mac) + Shift + P&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1469/24569403644_79a1f874f2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;出現輸入框後, 可以針對 Package的操作輸入以下 Keywords (ex. install、remove、list)&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1619/25173739056_94164dac33_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;常見的操作說明如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List Package&lt;/strong&gt;: 列出已安裝的 Package (這邊可以試著鍵入 list, 輸入框的模糊搜尋會幫你選取到match 的指令, 相當方便的使用者體驗)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Install Package&lt;/strong&gt;: 左下會有個移動的等號 "=" 表示正在搜尋可以安裝的Package, 耐心等待跑完之後, 會彈出類似下拉式的選單供選擇 (挑選欲安裝的Package一樣可以鍵入關鍵字, 讓模糊搜尋幫助你挑選)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remove Package&lt;/strong&gt;: 列出已安裝的Package, 提供選取刪除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外, 在挑選 Plugin 安裝的部分, 除了可以先上網看看相關領域開發者都推薦使用的之外, 也可上 &lt;a href="https://packagecontrol.io/packages/Package%20Control"&gt;Package Control 官網&lt;/a&gt; 透過一些關鍵字來尋找, 跟在Sublime裡面搜尋的差別在於, 官網上的會提供 Rank 讓你知道這個 Package 被安裝的熱門程度, 較多人使用的 Plugin 在維護跟品質上都相對比較有保障。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註&lt;/p&gt;
  
  &lt;p&gt;Cmd = Command key define in Mac Keyboard&lt;/p&gt;
  
  &lt;p&gt;&lt;code&gt;Ctrl/Cmd(Windows/Mac) + Shift + P&lt;/code&gt;, 透過這組快速鍵叫出來的是 Sublime 的 Command Palette (也可從 Menu 選單裡的 Tool 選項叫出來), 透過這個 Command Palette 可用來呼叫許多其他 Plugin 預設的功能, 所以絕大部份的時候只需要記得這個快速鍵, 就已經相當方便了。&lt;/p&gt;
  
  &lt;p&gt;Ex. git plugin也是在這個輸入框內做操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="step3"&gt;Step 3. 推薦一些筆者安裝使用的套件&lt;/h2&gt;

&lt;p&gt;(這裡先介紹一般通用的套件)&lt;/p&gt;

&lt;p&gt;透過 Package Control 都可以輕易的 Install 以下的 Plugin 協助你提升工作效率, 而需注意的是部分 Plugin 安裝之後, 有時會需要做一些客製化的調整 (例如修改 Package Setting 檔, 從 Menu 選單 Preferences -&gt; Package Setting -&gt; 挑選你要修改的 Plugin)&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1586/25174133666_ec6ba6156d_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;筆者似乎從 Sublime Text 3 開始就不能直接修改 Default 的 Setting, 需要打開 User 的 Setting 來做變更 (如上圖), 不過這也是建立良好修改習慣的開始。&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="highlightwordshttpspackagecontroliopackageshighlightwords"&gt;&lt;a href="https://packagecontrol.io/packages/HighlightWords"&gt;HighlightWords&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;這個套件的使用來自於 Source Insight 裡我覺得很方便的功能, 在 Source Insight 裡透過 &lt;code&gt;Shift + F8&lt;/code&gt; 來常駐 (持續性) 的標記某個單詞 (同時也會標記這整個文本裡所有出現的地方, 有助於 trace code), 但在 Sublime 中, 雖然選取文字時會幫你標記, 但滑鼠點擊它處則標記即消失, 無法保持持續標記 (&lt;mark&gt;Highlight&lt;/mark&gt;) 的狀態, 另外在剛接觸這個套件的版本所提供的方式, 是透過快速鍵後只會彈出最下排一個輸入框, 提供輸入想標記的單詞, 而要取消標記也是刪除這輸入框裡的內容, 隨著我跟前同事私下研究改進, 目前已可透過 &lt;code&gt;Cmd + Shift + H&lt;/code&gt; 來 Highlight 游標目前停留的字詞, 並對同樣的字詞再按一次快速鍵則取消標記, 使用方式已與Source Insight無異, 甚至更好用。&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="brackethighlighterhttpspackagecontroliopackagesbrackethighlighter"&gt;&lt;a href="https://packagecontrol.io/packages/BracketHighlighter"&gt;BracketHighlighter&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Trace code 滿常需要的除了前面標記變數的功能以外, 另外也需要幫忙判斷括號從哪括到哪, 這Plugin就提供了這樣的的幫助。&lt;/p&gt;

&lt;p&gt;注意, 這邊筆者會將Setting修改成如下, 以呈現較佳的視覺效果&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-json"&gt;"default": {
"icon": "dot",
// BH1's original default color for reference
"color": "entity.name.class",
//"color": "brackethighlighter.default",
"style": "block"
},
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h4 id="ctagshttpspackagecontroliopackagesctags"&gt;&lt;a href="https://packagecontrol.io/packages/CTags"&gt;Ctags&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;也是在 trace code 方面個人覺得非常好用的 Plugin 之一, 先介紹 ctags 本身是一個專門幫忙對 soruce code、header file 產生 index file 用的工具, 且在一開始最早僅支援 C, 後來延伸至今已可支援以下語言&lt;/p&gt;

&lt;p&gt;Ant、Asm、Asp、Awk、Basic、BETA、C、C++、C#、Cobol、DosBatch、Eiffel、Erlang、Flex、Fortran、HTML、Java、JavaScript、Lisp、Lua、Make、MatLab、OCaml、Pascal、Perl、PHP、Python、REXX、Ruby、Scheme、Sh、SLang、SML、SQL、Tcl、Tex、Vera、Verilog、VHDL、Vim、YACC&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以透過 Shell 底下的 Command 來查詢支援的語言&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;ctags --list-languages  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;另外 ctags 本身也可以支援對語言或副檔名做延伸的定義&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ex. 在Sublime中使用的話, 在 Ctags 的 Plugin Setting 內加入下面這句 (等於將後面參數傳給 ctags )  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-json"&gt;"opts" : ["--langmap=C:+.mq4", "--extra=+q", "--fields=+Saim", "--c-kinds=+lpx", "--c++-kinds=+lpx", "-R"],
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;--extra=+q --fields=+Saim&lt;/strong&gt; 指名要建立的 tags 包含 Class 內 member 的資訊&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--c-kinds=+lpx --c++-kinds=+lpx&lt;/strong&gt; 是用來對底下參數打開
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;l&lt;/strong&gt;  local variables [off]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;p&lt;/strong&gt;  function prototypes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt;  external and forward variable declarations [off]&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-R&lt;/strong&gt; 則是整個目錄底下遞迴的方式去循環查找建立 index&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--langmap=C:+.mq4&lt;/strong&gt; 是筆者想針對 MT4 平台開發程式, 副檔名使用的是 mq4, 但語法本身很接近 C 語言, 所以 extend C parser 來幫忙建立 tag file&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;另外透過以下指令可以看 ctags 對每個語言建立 index 的詳細程度, 部分可供 On/Off&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;ctags --list-kinds  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上大概介紹完ctags可以做到的事後, 就要開始介紹如何安裝。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mac Shell : brew install ctags (Mac 有自帶的 ctags 但無法使用, 記得要抓新的, 筆者使用的是 Exuberant Ctags 5.8)&lt;/li&gt;
&lt;li&gt;Ubuntu Shell: apt-get install ctags&lt;/li&gt;
&lt;li&gt;Windows: 有點久遠, 大概有執行可以抓下來安裝吧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;裝完之後記得修改User Setting加入&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-json"&gt;"command": "/usr/local/Cellar/ctags/5.8_1/bin/ctags",
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後面字串需對應到實際安裝 ctags 的執行檔路徑, 這樣便可以開始建立 index 使用了。
&lt;img src="https://farm2.staticflickr.com/1579/25123928811_0ef0bcb02c_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id="blockcursoreverywherehttpspackagecontroliopackagesblock20cursor20everywhere"&gt;&lt;a href="https://packagecontrol.io/packages/Block%20Cursor%20Everywhere"&gt;Block Cursor Everywhere&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;在文字編輯器內要尋找鍵盤的游標有時候也是種困擾, 這個 Plugin 可以幫忙在 Vim 指令 mode 下提供 &lt;mark&gt; 方塊形&lt;/mark&gt; 的鍵盤游標。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Vim Mode&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;如果有使用過Linux開發的話, 常用的 Console 文字編輯器有兩套 Vi/Vim or Emac (筆者是只接觸過 vim), 在 Vim 底下有提供兩種 mode: 指令 mode 以及編輯 mode, 以往已經使用習慣 Vim 的朋友可以透過修改 Sublime 的 Setting file 模擬 Vim, 分別是將&lt;/p&gt;
  
  &lt;p&gt;&lt;code&gt;"ignored_packages": ["Vintage"],&lt;/code&gt; 中的 Vintage 拿掉 (切換成可支援 Vim mode)&lt;/p&gt;
  
  &lt;p&gt;&lt;code&gt;"vintage_start_in_command_mode": true,&lt;/code&gt; 加入這行, (開啟檔案時會優先啟動 Vim 的 command mode), 這個 Plugin 是搭配 Vintage 使用, 可以幫忙快速定位到目前游標的位置, 加速編輯上的效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;最後下面是筆者習慣的 Theme 跟 Color Schemes , Theme 是整個軟體介面的主題樣式, 而 Color Scheme 是用來做語法上色時的配色樣本, 網路都有一些常用或是推薦的樣式, 甚至已經幫忙整理好預覽圖, 都可以從而參考找出自己需要的。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1604/25098884972_a69241ee7c_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;h4 id="themesodahttpspackagecontroliopackagestheme2020soda"&gt;&lt;a href="https://packagecontrol.io/packages/Theme%20-%20Soda"&gt;Theme - Soda&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class="language- language-json"&gt;"soda_classic_tabs": true,
"theme": "Soda Dark 3.sublime-theme",
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Add to Preferences.sublime-settings)&lt;/p&gt;

&lt;h4 id="tomorrowcolorschemeshttpspackagecontroliopackagestomorrow20color20schemes"&gt;&lt;a href="https://packagecontrol.io/packages/Tomorrow%20Color%20Schemes"&gt;Tomorrow Color Schemes&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class="language- language-json"&gt;"color_scheme": "Packages/Tomorrow Color Schemes/Tomorrow-Night.tmTheme",
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Add to Preferences.sublime-settings)&lt;/p&gt;</content:encoded></item><item><title>多空操作秘笈 筆記 (Mind Map)</title><description>&lt;blockquote&gt;
  &lt;p&gt;原名&lt;/p&gt;
  
  &lt;p&gt;Secrets For Profiting In Bull And Bear Markets by &lt;strong&gt;Stan Weinstein&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;別名&lt;/p&gt;
  
  &lt;p&gt;史丹溫斯坦稱傲牛熊市的秘密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;重點摘要、心得&lt;/h2&gt;

&lt;p&gt;書中強調的是透過 &lt;strong&gt;技術面&lt;/strong&gt; 來分析趨勢, 介紹的內容分別從最基本的術語解釋, 先跟讀者做認知上對齊的動作 (這部分也是筆者在閱讀此書上對作者用心感受最深的部分), 再來進入此書的正題, 趨勢的階段性介紹 (分別為打底、上升、頭部、下降四個階段), 教你如何辨認當前走勢是處於何種階段; 當瞭解了走勢呈現出的階段資訊後, 告訴讀者位在何時是合適的進場時機 (突破至第二階段以及連續買進的突破出現時), 搭配著作者羅列的圖表可以循序漸進的學習並練習, 最後再用額外的章節指導這門藝術要如何更加精煉, 到此我們已完成了前半部的工程 (套書中的說法就是 - 「&lt;strong&gt;你已經登堂了&lt;/strong&gt;」)。&lt;/p&gt;

&lt;p&gt;第二部分則是要教導讀者如何留住獲利, 在盡可能準確的時刻下轎 (透過正確的觀念建立追蹤止損點來保護獲利), 並在適當的時間可以放空來增加獲利, 而做空的分析方式其實跟做多恰為相反, 領悟力高的讀者應該不難舉一反三。&lt;/p&gt;

&lt;p&gt;最後一部分作者說明了一些用來追蹤市場走勢的長期指標 (因為在前幾章節所介紹的準則之一就是 -「不要違背市場操作」), 也補充了股市以外運用其分析方式操作得宜的投資實例 (基金、&lt;/p&gt;</description><link>http://localhost:2368/duo-kong-cao-zuo-mi-ji-bi-ji/</link><guid isPermaLink="false">f730b870-ed59-44e3-944d-9a29ae5ea53a</guid><category>Mind Map</category><category>史丹溫斯坦</category><category>Stan Weinstein</category><dc:creator>Captain Vincent</dc:creator><pubDate>Sat, 20 Feb 2016 18:36:48 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;原名&lt;/p&gt;
  
  &lt;p&gt;Secrets For Profiting In Bull And Bear Markets by &lt;strong&gt;Stan Weinstein&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;別名&lt;/p&gt;
  
  &lt;p&gt;史丹溫斯坦稱傲牛熊市的秘密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;重點摘要、心得&lt;/h2&gt;

&lt;p&gt;書中強調的是透過 &lt;strong&gt;技術面&lt;/strong&gt; 來分析趨勢, 介紹的內容分別從最基本的術語解釋, 先跟讀者做認知上對齊的動作 (這部分也是筆者在閱讀此書上對作者用心感受最深的部分), 再來進入此書的正題, 趨勢的階段性介紹 (分別為打底、上升、頭部、下降四個階段), 教你如何辨認當前走勢是處於何種階段; 當瞭解了走勢呈現出的階段資訊後, 告訴讀者位在何時是合適的進場時機 (突破至第二階段以及連續買進的突破出現時), 搭配著作者羅列的圖表可以循序漸進的學習並練習, 最後再用額外的章節指導這門藝術要如何更加精煉, 到此我們已完成了前半部的工程 (套書中的說法就是 - 「&lt;strong&gt;你已經登堂了&lt;/strong&gt;」)。&lt;/p&gt;

&lt;p&gt;第二部分則是要教導讀者如何留住獲利, 在盡可能準確的時刻下轎 (透過正確的觀念建立追蹤止損點來保護獲利), 並在適當的時間可以放空來增加獲利, 而做空的分析方式其實跟做多恰為相反, 領悟力高的讀者應該不難舉一反三。&lt;/p&gt;

&lt;p&gt;最後一部分作者說明了一些用來追蹤市場走勢的長期指標 (因為在前幾章節所介紹的準則之一就是 -「不要違背市場操作」), 也補充了股市以外運用其分析方式操作得宜的投資實例 (基金、選擇權、期貨皆有著墨), 在文末作者總結認為紙上談兵不如下場練習 (心態上的不同會導致操作上的差別), 盼讀者可以先投以小部分資金進入市場磨練慢慢改善自己的技巧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;筆者按 : 本書的結構內容及深淺編排得非常之好, 在閱讀上絲毫不覺得自己在投資領域還只是個初心者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;h2 id="mindmap"&gt;筆記 (Mind Map)&lt;/h2&gt;

&lt;p&gt;底下是採用 &lt;a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E5%9B%BE"&gt;Mind Map&lt;/a&gt; 方式對此書做的筆記 (包含選用合適的工具、閱讀書籍, 筆記著實花了筆者相當久的時間), 若有他人也能從中有所領悟的話, 筆者也會深感欣慰。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用方式類似 Google Map 的拖曳操作可以移動畫面, 右鍵可以彈出放大鏡的按鈕, 按壓放大鏡拖曳後可以 Zoom In/Out&lt;/p&gt;
&lt;/blockquote&gt;

&lt;iframe width="853" height="480" src="https://embed.coggle.it/diagram/Vsbpjos-o0NjzNTF/8a429b96d7098f33ba01c968075a2d3733cf8771d6c29faf87f84efe919e8b31" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</content:encoded></item><item><title>How to setup Ghost blog platform (下)</title><description>&lt;blockquote&gt;
  &lt;p&gt;接著進入下一個主題, 如何部署 Ghost 到 git.io 以及 Ghost 進階的功能設定
  &lt;strong&gt;(Syntax highlight, 使用 Disqus 添加留言功能, 添加 Google Analytics&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Buster &lt;a href="http://blog.axitkhurana.com/introducing-ghost/"&gt;作者Blog中介紹&lt;/a&gt; 有提到是受了 Octopress 的啟發以及在命名上由來的惡趣味, ker ker... Ghostbusters &lt;del&gt;又透露自己年紀了&lt;/del&gt; &lt;br&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/en/c/c7/Ghostbusters_cover.png" alt=""&gt;&lt;/p&gt;

&lt;h2 id="ghostgitio"&gt;部署 Ghost 到 git.io&lt;/h2&gt;

&lt;p&gt;首先要部署 Ghost 到 git.io 需要先安裝 python 以及套件 &lt;a href="https://github.com/axitkhurana/buster"&gt;buster&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;brew install python  
sudo pip install buster  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/32862072/attempting-to-install-buster-with-pip-on-mac"&gt;[Issue 1]&lt;/a&gt; 參考自&lt;/p&gt;</description><link>http://localhost:2368/how-to-setup-ghost-blog-platform-xia/</link><guid isPermaLink="false">4d889d8f-ae98-47a4-81cc-445ac9ac618e</guid><category>Ghost</category><category>Octopress</category><category>prismjs</category><category>Disqus</category><dc:creator>Captain Vincent</dc:creator><pubDate>Wed, 03 Feb 2016 10:57:59 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;接著進入下一個主題, 如何部署 Ghost 到 git.io 以及 Ghost 進階的功能設定
  &lt;strong&gt;(Syntax highlight, 使用 Disqus 添加留言功能, 添加 Google Analytics&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Buster &lt;a href="http://blog.axitkhurana.com/introducing-ghost/"&gt;作者Blog中介紹&lt;/a&gt; 有提到是受了 Octopress 的啟發以及在命名上由來的惡趣味, ker ker... Ghostbusters &lt;del&gt;又透露自己年紀了&lt;/del&gt; &lt;br&gt;
&lt;img src="http://upload.wikimedia.org/wikipedia/en/c/c7/Ghostbusters_cover.png" alt=""&gt;&lt;/p&gt;

&lt;h2 id="ghostgitio"&gt;部署 Ghost 到 git.io&lt;/h2&gt;

&lt;p&gt;首先要部署 Ghost 到 git.io 需要先安裝 python 以及套件 &lt;a href="https://github.com/axitkhurana/buster"&gt;buster&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;brew install python  
sudo pip install buster  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/32862072/attempting-to-install-buster-with-pip-on-mac"&gt;[Issue 1]&lt;/a&gt; 參考自 Stackoverflow, 在安裝 &lt;code&gt;sudo pip install buster&lt;/code&gt; 出現錯誤時, 可以看看是否同樣是因為&lt;mark&gt;尚未安裝 xcode 的command line tool 所造成的&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;然後在 Ghost 目錄底下建立一個名為 static 的資料夾, 指向 github 上 git.io 的 repo&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;git clone git@github.com:username/username.github.io.git static  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以手動方式完成(筆者是採用這種方式) 或是直接使用 Buster 提供的 command 來幫忙&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;buster setup [--gh-repo=&amp;lt;repo-url&amp;gt;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著透過以下指令分別產生完靜態頁面, 並透過 Browser 預覽產生完的結果&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;buster generate --domain=http://localhost:2368  
buster preview  
open http://localhost:9000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後就可以將 Ghost 以及日後做的變更 deploy 到 git.io 上囉。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;buster deploy  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h2 id="syntaxhighlightinghost"&gt;Syntax Highlight in Ghost&lt;/h2&gt;

&lt;p&gt;使用 &lt;a href="http://prismjs.com/download.html"&gt;prismjs&lt;/a&gt; , 首先先至官網上如下圖操作&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1468/24679275812_eb4f8dafe5_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;透過預覽來選擇不同的 Theme , 這邊設計有點詭異的地方在 preview window 在網頁底部  &lt;/li&gt;
&lt;li&gt;瀏覽完後再選擇你想使用的 Theme  &lt;/li&gt;
&lt;li&gt;接著勾選要支援 syntax highlight 的語言  &lt;/li&gt;
&lt;li&gt;接下來移至網頁底部分別按下按鈕來下載 js 與 css 檔案 (prism.css &amp;amp; prism.js)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1612/24797117325_4a9c842678.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;下載完後再將 prism.css &amp;amp; prism.js 分別放置當前 Ghost 所使用的 Theme 底下路徑中 (Ghost 所預設使用的 Theme 為 casper)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/content/themes/[theme name]/assets/css/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;與&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/content/themes/[theme name]/assets/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著修改以下路徑的檔案&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/content/themes/[theme name]/default.hbs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在該檔案內分別&lt;mark&gt;添加以下關於 prism.css 與 prism.js 修改的兩行 Code&lt;/mark&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;    &amp;lt;link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" /&amp;gt;
    &amp;lt;link rel="stylesheet" type="text/css" href="{{asset "css/prism.css"}}" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;與&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;    &amp;lt;script type="text/javascript" src="{{asset "js/jquery.fitvids.js"}}"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type="text/javascript" src="{{asset "js/prism.js"}}"&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著就可以在文章中添加以下的寫法來測試一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ``` language-javascript
 var s = "JavaScript syntax highlighting";  
 alert(s); 
 ```
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h2 id="disqus"&gt;添加 Disqus 留言功能&lt;/h2&gt;

&lt;p&gt;Reference Page &lt;a href="http://academy.ghost.org/adding-disqus-to-your-ghost-blog/"&gt;Adding Disqus to your Ghost blog&lt;/a&gt; &lt;br&gt;
參考官網教學上的做法即可, &lt;del&gt;故省略翻譯&lt;/del&gt; XD&lt;/p&gt;

&lt;p&gt;第一步先註冊一個 Disqus 帳號&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1570/24187392983_8947254fb3_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;登入後先點選右上角的 Setting 選項 Add Disqus To Site&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1639/24814247255_60a5425209_n.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;再點選下圖中間的 Start Using Engage 或右上方 Install on Your Site 進入取得識別用的 Disqus URL&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1546/24186062574_15a900c299_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;註冊一個識別用的 Disqus URL&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1695/24187392843_907fa17378_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;取得用來內嵌的 Disqus Script&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1719/24186062594_26746cf4f3.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;接著會得到的類似以下內文的 Script&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;&amp;lt;div id="disqus_thread"&amp;gt;&amp;lt;/div&amp;gt;  
&amp;lt;script&amp;gt;  
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {  
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable  
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable  
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');

    s.src = '//captainvincent.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
&amp;lt;/script&amp;gt;  
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href="https://disqus.com/?ref_noscript" rel="nofollow"&amp;gt;comments powered by Disqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再透過修改底下路徑的檔案, 將 Script 貼入希望放置留言區的地方, 目前筆者是放在 footer 區塊裡的 &lt;code&gt;&amp;lt;section class="share"&amp;gt;&lt;/code&gt; 之後&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;content/themes/[theme name]/post.hbs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並修改剛貼入的 Script 中底下的四行, 先將註解符號 &lt;code&gt;/*&lt;/code&gt; &lt;code&gt;*/&lt;/code&gt; 移除,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;/*
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable  
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable  
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後再將 &lt;code&gt;PAGE_URL&lt;/code&gt; 置換成 &lt;code&gt;'{{@blog.url}}{{url}}'&lt;/code&gt;, &lt;code&gt;PAGE_IDENTIFIER&lt;/code&gt; 置換成 &lt;code&gt;'ghost-{{id}}'&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-javascript"&gt;this.page.url = '{{@blog.url}}{{url}}';  
this.page.identifier = 'ghost-{{id}}';  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
存擋完畢就大功告成了。&lt;/p&gt;

&lt;h2 id="googleanalytics"&gt;添加 Google Analytics&lt;/h2&gt;

&lt;p&gt;先建立 &lt;a href="https://accounts.google.com/SignUpExpress?service=analytics&amp;amp;continue=https%3A%2F%2Fanalytics.google.com%2Fanalytics%2Fweb%2F"&gt;Google Analytisc Account&lt;/a&gt; , 並先取得 Tracking Code 類似下圖 &lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1519/24520255780_f1e379d615.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;再透過 Ghost Platform 所提供的管理頁面選項 Code Injection&lt;/p&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1664/24789705376_446840ebd2_z.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;選擇右上角 Save 之後就完成了。&lt;/p&gt;</content:encoded></item><item><title>How to setup Ghost blog platform (上)</title><description>&lt;p&gt;Reference Page &lt;a href="https://stefanscherer.github.io/setup-ghost-for-github-pages/"&gt;setup-ghost-for-github-pages&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;用 Setup Ghost 作為 Ghost 部落格的第一篇文章也滿別具意義的, 不過在最一開始 Survey 時選用架設 Blog 的 Framework 是 &lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; , 但隨著架設完後一邊試用的體悟, 發現整個操作還真是 &lt;del&gt;Suck&lt;/del&gt; Geek啊! 只好再廣泛的涉略一下後選用了 Ghost。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1532/24635687672_85473e64a4_z.jpg" alt=""&gt;
雖然 Octopress 與其同為支援 Ｍarkdown 的語法, 但選用Ghost的最大好處是後台已經整合了 Markdown的即視編輯器 (可能還稱不上殺手應用, 但已深得我心)&lt;/p&gt;

&lt;h2 id="beforeinstallnodejs"&gt;Before Install Node.js&lt;/h2&gt;

&lt;p&gt;Ghost 是用 Node.js 打造, 所以在執行過程中需要啟動 &lt;a href="https://zh.wikipedia.org/wiki/Node.js"&gt;Node.js&lt;/a&gt; &lt;br&gt;
而在 Mac 環境上安裝軟體套件目前常見的方式是透過 brew (也是參考網頁所上提供的)&lt;/p&gt;</description><link>http://localhost:2368/how-to-setup-ghost/</link><guid isPermaLink="false">bcd278b7-b38d-43c2-8b45-a3ffb2eb919f</guid><category>Ghost</category><category>Octopress</category><dc:creator>Captain Vincent</dc:creator><pubDate>Mon, 01 Feb 2016 15:41:06 GMT</pubDate><content:encoded>&lt;p&gt;Reference Page &lt;a href="https://stefanscherer.github.io/setup-ghost-for-github-pages/"&gt;setup-ghost-for-github-pages&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;用 Setup Ghost 作為 Ghost 部落格的第一篇文章也滿別具意義的, 不過在最一開始 Survey 時選用架設 Blog 的 Framework 是 &lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; , 但隨著架設完後一邊試用的體悟, 發現整個操作還真是 &lt;del&gt;Suck&lt;/del&gt; Geek啊! 只好再廣泛的涉略一下後選用了 Ghost。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="https://farm2.staticflickr.com/1532/24635687672_85473e64a4_z.jpg" alt=""&gt;
雖然 Octopress 與其同為支援 Ｍarkdown 的語法, 但選用Ghost的最大好處是後台已經整合了 Markdown的即視編輯器 (可能還稱不上殺手應用, 但已深得我心)&lt;/p&gt;

&lt;h2 id="beforeinstallnodejs"&gt;Before Install Node.js&lt;/h2&gt;

&lt;p&gt;Ghost 是用 Node.js 打造, 所以在執行過程中需要啟動 &lt;a href="https://zh.wikipedia.org/wiki/Node.js"&gt;Node.js&lt;/a&gt; &lt;br&gt;
而在 Mac 環境上安裝軟體套件目前常見的方式是透過 brew (也是參考網頁所上提供的), 但因為遇到了以下問題所以又花了些時間一一排除, 這邊稍微做簡單的說明避免大家繞路。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;透過 brew 無法安裝目前 Ghost 所相容的版本, 在啟動時出現以下 Error Message &lt;br&gt;
&lt;code&gt;Ghost needs Node version ~0.10.0 || ~0.12.0 || ~4.2.0 you are using version 5.4.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修正後的做法, 改先透過安裝 nvm(node version manager) &lt;code&gt;brew install nvm&lt;/code&gt; 之後再進行指定版本的 node.js 安裝 &lt;a href="http://icarus4.logdown.com/posts/175092-nodejs-installation-guide"&gt;參考網頁&lt;/a&gt; , &lt;br&gt;
但後續仍會遇到 &lt;a href="https://github.com/creationix/nvm/issues/855"&gt;https://github.com/creationix/nvm/issues/855&lt;/a&gt; 的問題, 需透過多餘的指令解決衝突的部分, &lt;br&gt;
&lt;code&gt;NVM is not compatible with the npm config "prefix"&lt;/code&gt; &lt;br&gt;
並且會導致 Shell start-up latency 時間拉長&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;所以最終的建議做法是 follow &lt;a href="https://github.com/creationix/nvm"&gt;nvm官網&lt;/a&gt; 指令來安裝 nvm , 如下&lt;/strong&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;git clone https://github.com/creationix/nvm.git ~/.nvm &amp;amp;&amp;amp; cd ~/.nvm &amp;amp;&amp;amp; git checkout `git describe --abbrev=0 --tags`  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將以下行加入 ~/.bashrc, ~/.profile, or ~/.zshrc, 讓系統自動幫你在登入時 source 完 script&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;export NVM_DIR="$HOME/.nvm"  
[ -s "$NVM_DIR/nvm.sh" ] &amp;amp;&amp;amp; . "$NVM_DIR/nvm.sh" # This loads nvm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;By the way&lt;/strong&gt; 官網也就有提到 &lt;mark&gt;Homebrew installation is not supported.&lt;/mark&gt;&lt;/p&gt;

&lt;h2 id="installnodejs"&gt;Install Node.js&lt;/h2&gt;

&lt;p&gt;在順利安裝完 nvm 之後, 透過以下指令可以秀出目前 nvm 的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;nvm ls-remote  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並再以指令安裝建議的版本, 筆者目前安裝的版本為 Ghost 所建議的 4.2.0&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;nvm install 4.2.0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定所使用的 Node.js version&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;nvm use 4.2.0  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="downloadandinstallghost"&gt;Download and Install Ghost&lt;/h2&gt;

&lt;p&gt;Check for the latest version of Ghost from &lt;a href="https://ghost.org/download/"&gt;Ghost.org&lt;/a&gt;  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;mkdir ghost  
cd ghost  
wget --no-check-certificate https://ghost.org/zip/ghost-0.7.5.zip  
unzip ghost-0.7.5.zip  
npm install --production  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;npm 全名為 Node Package Manager，是 Node.js 的套件（package）管理工具, 透過 &lt;code&gt;npm install&lt;/code&gt; 會安裝 node.js 應用程序底下, package.json 文本中 dependencies 指定的相關套件, 透過這樣的方式可以降低拿到該應用程序在執行環境建立的複雜度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="startghost"&gt;Start Ghost&lt;/h2&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;npm start  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="logintoghost"&gt;Login to Ghost&lt;/h2&gt;

&lt;p&gt;透過 Browser 開啟以下網址連結到設定頁面, 也可以閱讀 Ghost 幫使用者預設好的第一篇文章 Welcome to Ghost 上所提供的資訊&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- language-bash"&gt;open http://localhost:2368/ghost  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;總結&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;透過以上的步驟就可以在本地端建立一個部落格平台, 下一章節會繼續介紹如何將本地端的部落格部署到 git.io 上。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>